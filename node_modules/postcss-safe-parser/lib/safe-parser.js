'use strict';

exports.__esModule = true;

var _tokenize2 = require('postcss/lib/tokenize');

var _tokenize3 = _interopRequireDefault(_tokenize2);

var _comment = require('postcss/lib/comment');

var _comment2 = _interopRequireDefault(_comment);

var _parser = require('postcss/lib/parser');

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SafeParser = function (_Parser) {
    _inherits(SafeParser, _Parser);

    function SafeParser() {
        _classCallCheck(this, SafeParser);

        return _possibleConstructorReturn(this, _Parser.apply(this, arguments));
    }

    SafeParser.prototype.tokenize = function tokenize() {
        this.tokens = (0, _tokenize3.default)(this.input, { ignoreErrors: true });
    };

    SafeParser.prototype.comment = function comment(token) {
        var node = new _comment2.default();
        this.init(node, token[2], token[3]);
        node.source.end = { line: token[4], column: token[5] };

        var text = token[1].slice(2);
        if (text.slice(-2) === '*/') text = text.slice(0, -2);

        if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
        } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
        }
    };

    SafeParser.prototype.decl = function decl(tokens) {
        if (tokens.length > 1 || tokens[0][0] !== ':') {
            _Parser.prototype.decl.call(this, tokens);
        }
    };

    SafeParser.prototype.unclosedBracket = function unclosedBracket() {};

    SafeParser.prototype.unknownWord = function unknownWord(start) {
        var buffer = this.tokens.slice(start, this.pos + 1);
        this.spaces += buffer.map(function (i) {
            return i[1];
        }).join('');
    };

    SafeParser.prototype.unexpectedClose = function unexpectedClose() {
        this.current.raws.after += '}';
    };

    SafeParser.prototype.doubleColon = function doubleColon() {};

    SafeParser.prototype.unnamedAtrule = function unnamedAtrule(node) {
        node.name = '';
    };

    SafeParser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false) return;

        var split = void 0;
        for (split = colon - 1; split >= 0; split--) {
            if (tokens[split][0] === 'word') break;
        }
        for (split -= 1; split >= 0; split--) {
            if (tokens[split][0] !== 'space') {
                split += 1;
                break;
            }
        }
        var other = tokens.splice(split, tokens.length - split);
        this.decl(other);
    };

    SafeParser.prototype.checkMissedSemicolon = function checkMissedSemicolon() {};

    SafeParser.prototype.endFile = function endFile() {
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;

        while (this.current.parent) {
            this.current = this.current.parent;
            this.current.raws.after = '';
        }
    };

    return SafeParser;
}(_parser2.default);

exports.default = SafeParser;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNhZmUtcGFyc2VyLmVzNiJdLCJuYW1lcyI6WyJTYWZlUGFyc2VyIiwidG9rZW5pemUiLCJ0b2tlbnMiLCJpbnB1dCIsImlnbm9yZUVycm9ycyIsImNvbW1lbnQiLCJ0b2tlbiIsIm5vZGUiLCJpbml0Iiwic291cmNlIiwiZW5kIiwibGluZSIsImNvbHVtbiIsInRleHQiLCJzbGljZSIsInRlc3QiLCJyYXdzIiwibGVmdCIsInJpZ2h0IiwibWF0Y2giLCJkZWNsIiwibGVuZ3RoIiwidW5jbG9zZWRCcmFja2V0IiwidW5rbm93bldvcmQiLCJzdGFydCIsImJ1ZmZlciIsInBvcyIsInNwYWNlcyIsIm1hcCIsImkiLCJqb2luIiwidW5leHBlY3RlZENsb3NlIiwiY3VycmVudCIsImFmdGVyIiwiZG91YmxlQ29sb24iLCJ1bm5hbWVkQXRydWxlIiwibmFtZSIsInByZWNoZWNrTWlzc2VkU2VtaWNvbG9uIiwiY29sb24iLCJzcGxpdCIsIm90aGVyIiwic3BsaWNlIiwiY2hlY2tNaXNzZWRTZW1pY29sb24iLCJlbmRGaWxlIiwibm9kZXMiLCJzZW1pY29sb24iLCJwYXJlbnQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVxQkEsVTs7Ozs7Ozs7O3lCQUVqQkMsUSx1QkFBVztBQUNQLGFBQUtDLE1BQUwsR0FBYyx3QkFBUyxLQUFLQyxLQUFkLEVBQXFCLEVBQUVDLGNBQWMsSUFBaEIsRUFBckIsQ0FBZDtBQUNILEs7O3lCQUVEQyxPLG9CQUFRQyxLLEVBQU87QUFDWCxZQUFJQyxPQUFPLHVCQUFYO0FBQ0EsYUFBS0MsSUFBTCxDQUFVRCxJQUFWLEVBQWdCRCxNQUFNLENBQU4sQ0FBaEIsRUFBMEJBLE1BQU0sQ0FBTixDQUExQjtBQUNBQyxhQUFLRSxNQUFMLENBQVlDLEdBQVosR0FBa0IsRUFBRUMsTUFBTUwsTUFBTSxDQUFOLENBQVIsRUFBa0JNLFFBQVFOLE1BQU0sQ0FBTixDQUExQixFQUFsQjs7QUFFQSxZQUFJ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QUFiLENBQWtCaUIsS0FBbEIsR0FBMEIsQ0FBQyxLQUFLRCxPQUFMLENBQWFoQixJQUFiLENBQWtCaUIsS0FBbEIsSUFBMkIsRUFBNUIsSUFBa0MsS0FBS04sTUFBakU7O0FBRUEsZUFBUSxLQUFLSyxPQUFMLENBQWFjLE1BQXJCLEVBQThCO0FBQzFCLGlCQUFLZCxPQUFMLEdBQWUsS0FBS0EsT0FBTCxDQUFhYyxNQUE1QjtBQUNBLGlCQUFLZCxPQUFMLENBQWFoQixJQUFiLENBQWtCaUIsS0FBbEIsR0FBMEIsRUFBMUI7QUFDSDtBQUNKLEs7Ozs7O2tCQS9FZ0JqQyxVIiwiZmlsZSI6InNhZmUtcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHRva2VuaXplIGZyb20gJ3Bvc3Rjc3MvbGliL3Rva2VuaXplJztcbmltcG9ydCBDb21tZW50ICBmcm9tICdwb3N0Y3NzL2xpYi9jb21tZW50JztcbmltcG9ydCBQYXJzZXIgICBmcm9tICdwb3N0Y3NzL2xpYi9wYXJzZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTYWZlUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcblxuICAgIHRva2VuaXplKCkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VuaXplKHRoaXMuaW5wdXQsIHsgaWdub3JlRXJyb3JzOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGNvbW1lbnQodG9rZW4pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgQ29tbWVudCgpO1xuICAgICAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5bMl0sIHRva2VuWzNdKTtcbiAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0geyBsaW5lOiB0b2tlbls0XSwgY29sdW1uOiB0b2tlbls1XSB9O1xuXG4gICAgICAgIGxldCB0ZXh0ID0gdG9rZW5bMV0uc2xpY2UoMik7XG4gICAgICAgIGlmICggdGV4dC5zbGljZSgtMikgPT09ICcqLycgKSB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMik7XG5cbiAgICAgICAgaWYgKCAvXlxccyokLy50ZXN0KHRleHQpICkge1xuICAgICAgICAgICAgbm9kZS50ZXh0ICAgICAgID0gJyc7XG4gICAgICAgICAgICBub2RlLnJhd3MubGVmdCAgPSB0ZXh0O1xuICAgICAgICAgICAgbm9kZS5yYXdzLnJpZ2h0ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpbXlxcc10pKFxccyopJC8pO1xuICAgICAgICAgICAgbm9kZS50ZXh0ICAgICAgID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBub2RlLnJhd3MubGVmdCAgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG5vZGUucmF3cy5yaWdodCA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjbCh0b2tlbnMpIHtcbiAgICAgICAgaWYgKCB0b2tlbnMubGVuZ3RoID4gMSB8fCB0b2tlbnNbMF1bMF0gIT09ICc6JyApIHtcbiAgICAgICAgICAgIHN1cGVyLmRlY2wodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuY2xvc2VkQnJhY2tldCgpIHsgfVxuXG4gICAgdW5rbm93bldvcmQoc3RhcnQpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciAgID0gdGhpcy50b2tlbnMuc2xpY2Uoc3RhcnQsIHRoaXMucG9zICsgMSk7XG4gICAgICAgIHRoaXMuc3BhY2VzICs9IGJ1ZmZlci5tYXAoIGkgPT4gaVsxXSApLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHVuZXhwZWN0ZWRDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgKz0gJ30nO1xuICAgIH1cblxuICAgIGRvdWJsZUNvbG9uKCkgeyB9XG5cbiAgICB1bm5hbWVkQXRydWxlKG5vZGUpIHtcbiAgICAgICAgbm9kZS5uYW1lID0gJyc7XG4gICAgfVxuXG4gICAgcHJlY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgICAgIGxldCBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKTtcbiAgICAgICAgaWYgKCBjb2xvbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNwbGl0O1xuICAgICAgICBmb3IgKCBzcGxpdCA9IGNvbG9uIC0gMTsgc3BsaXQgPj0gMDsgc3BsaXQtLSApIHtcbiAgICAgICAgICAgIGlmICggdG9rZW5zW3NwbGl0XVswXSA9PT0gJ3dvcmQnICkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICggc3BsaXQgLT0gMTsgc3BsaXQgPj0gMDsgc3BsaXQtLSApIHtcbiAgICAgICAgICAgIGlmICggdG9rZW5zW3NwbGl0XVswXSAhPT0gJ3NwYWNlJyApIHtcbiAgICAgICAgICAgICAgICBzcGxpdCArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdGhlciA9IHRva2Vucy5zcGxpY2Uoc3BsaXQsIHRva2Vucy5sZW5ndGggLSBzcGxpdCk7XG4gICAgICAgIHRoaXMuZGVjbChvdGhlcik7XG4gICAgfVxuXG4gICAgY2hlY2tNaXNzZWRTZW1pY29sb24oKSB7IH1cblxuICAgIGVuZEZpbGUoKSB7XG4gICAgICAgIGlmICggdGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCAnJykgKyB0aGlzLnNwYWNlcztcblxuICAgICAgICB3aGlsZSAoIHRoaXMuY3VycmVudC5wYXJlbnQgKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxufVxuIl19
