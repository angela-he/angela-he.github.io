'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var postcss = require('postcss');

var affectedProps = require('./affected-props');

var _require = require('./options'),
    validateOptions = _require.validateOptions;

var _require2 = require('./keyframes'),
    isKeyframeRule = _require2.isKeyframeRule,
    isKeyframeAlreadyProcessed = _require2.isKeyframeAlreadyProcessed,
    isKeyframeSymmetric = _require2.isKeyframeSymmetric,
    rtlifyKeyframe = _require2.rtlifyKeyframe;

var _require3 = require('./rules'),
    getDirRule = _require3.getDirRule,
    processSrcRule = _require3.processSrcRule;

var _require4 = require('./decls'),
    rtlifyDecl = _require4.rtlifyDecl,
    ltrifyDecl = _require4.ltrifyDecl;

var _require5 = require('./selectors'),
    isSelectorHasDir = _require5.isSelectorHasDir;

module.exports = postcss.plugin('postcss-rtl', function (options) {
  return function (css) {

    var keyframes = [];

    options = validateOptions(options);

    var handleIgnores = function handleIgnores() {
      var removeComments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var isIgnored = false;
      var continuousIgnore = false;

      return function (node) {
        if (node.type === 'comment') {
          var text = node.text;

          switch (true) {
            case /^(!\s)?rtl:ignore$/.test(text):
              isIgnored = true;
              continuousIgnore = continuousIgnore || false;
              removeComments && node.remove();
              break;
            case /^(!\s)?rtl:begin:ignore$/.test(text):
              isIgnored = true;
              continuousIgnore = true;
              removeComments && node.remove();
              break;
            case /^(!\s)?rtl:end:ignore$/.test(text):
              isIgnored = false;
              continuousIgnore = false;
              removeComments && node.remove();
              break;
          }
          return true;
        }
        if (!continuousIgnore && isIgnored) {
          isIgnored = false;
          return true;
        }
        return isIgnored;
      };
    };

    var isKeyframeIgnored = handleIgnores();
    var isRuleIgnored = handleIgnores(true);

    // collect @keyframes
    css.walk(function (rule) {

      if (isKeyframeIgnored(rule)) return;
      if (rule.type !== 'atrule') return;

      if (!isKeyframeRule(rule)) return;
      if (isKeyframeAlreadyProcessed(rule)) return;
      if (isKeyframeSymmetric(rule)) return;

      keyframes.push(rule.params);
      rtlifyKeyframe(rule, options);
    });

    var valueIgnoreDirective = /\/\* *rtl *: *ignore *\*\/$/;
    var valuePrependDirective = /\/\* *rtl *: *prepend *: *([\S| ]*?) *\*\/$/;
    var valueAppendDirective = /\/\* *rtl *: *append *: *([\S| ]*?) *\*\/$/;
    var valueReplacementDirective = /\/\* *rtl *: *([\S| ]*?) *\*\/$/;

    var handleValueDirectives = function handleValueDirectives(decl, ltrDecls, rtlDecls) {
      var _ref = decl.raws.value || {},
          raw = _ref.raw;

      // Is there NO raw value?


      if (!raw) return false;

      // Does the raw value contain an ignore directive?
      if (raw.match(valueIgnoreDirective)) return true;

      // Extract directive values using RegExp.

      var _map = [valuePrependDirective, valueAppendDirective, valueReplacementDirective].map(function (regEx) {
        return (raw.match(regEx) || {})[1];
      }),
          _map2 = _slicedToArray(_map, 3),
          prependValue = _map2[0],
          appendValue = _map2[1],
          replaceValue = _map2[2];

      var addDecls = function addDecls(value) {
        // Create LTR declaration.
        ltrDecls.push(ltrifyDecl(decl, keyframes));

        // Create RTL declaration with replacement value and add.
        var rtlClonedDecl = decl.clone({
          value: value
        });
        rtlClonedDecl.raws.value = {
          value: value,
          raw: value
        };
        rtlDecls.push(rtlClonedDecl);

        return true;
      };

      // Does the raw value contain a prepend directive?
      if (prependValue) {
        return addDecls([prependValue, decl.value].join(' '));
      }

      // Does the raw value contain an append directive?
      if (appendValue) {
        return addDecls([decl.value, appendValue].join(' '));
      }

      // Does the raw value contain a replace directive?
      if (replaceValue) {
        return addDecls(replaceValue);
      }

      return false;
    }; // Simple rules (includes rules inside @media-queries)
    css.walk(function (node) {
      var ltrDecls = [];
      var rtlDecls = [];
      var dirDecls = [];

      if (isRuleIgnored(node)) return;

      if (node.type !== 'rule') {
        return;
      }
      var rule = node;

      if (isSelectorHasDir(rule.selector, options)) return;
      if (isKeyframeRule(rule.parent)) return;

      rule.walkDecls(function (decl) {
        // Is there a  value directive?
        if (handleValueDirectives(decl, ltrDecls, rtlDecls)) return;

        var rtl = rtlifyDecl(decl, keyframes);

        if (rtl) {
          ltrDecls.push(ltrifyDecl(decl, keyframes));
          rtlDecls.push(decl.clone(rtl));
          return;
        }

        if (affectedProps.indexOf(decl.prop) >= 0) {
          dirDecls.push(decl);
          decl.remove();
        }
      });

      if (rtlDecls.length) {
        if (!options.onlyDirection || options.onlyDirection === 'rtl') {
          getDirRule(rule, 'rtl', options).append(rtlDecls);
        }

        var ltrDirRule = getDirRule(rule, 'ltr', options);
        ltrDecls.forEach(function (_decl) {
          _decl.cleanRaws(_decl.root() === ltrDirRule.root());
          rule.removeChild(_decl);
          if (!options.onlyDirection || options.onlyDirection === 'ltr') {
            ltrDirRule.append(_decl);
          }
        });

        if (options.onlyDirection && options.onlyDirection === 'rtl') {
          ltrDirRule.remove();
        }
      }

      if (dirDecls.length) {
        getDirRule(rule, 'dir', options).append(dirDecls);
      }

      /* set dir attrs */
      processSrcRule(rule, options);
    });
    return false;
  };
});